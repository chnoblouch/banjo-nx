struct Device {
    var handle: addr;
}

struct MemBlock {
    var handle: addr;
}

struct CmdBuf {
    var handle: addr;

    pub func add_memory(self, mem: MemBlock, offset: u32, size: u32) {
        cmd_buf_add_memory(*self, mem, offset, size);
    }

    pub func finish_list(self) -> CmdList {
        return cmd_buf_finish_list(*self);
    }

    pub func bind_render_target(self, color_target: *ImageView, depth_target: *ImageView) {
        self.bind_render_targets(&color_target, 1, depth_target);
    }

    pub func bind_render_targets(self, color_targets: **ImageView, num_color_targets: u32, depth_target: *ImageView) {
        cmd_buf_bind_render_targets(*self, color_targets, num_color_targets, depth_target);
    }

    pub func bind_rasterizer_state(self, state: *RasterizerState) {
        cmd_buf_bind_rasterizer_state(*self, state);
    }

    pub func bind_color_state(self, state: *ColorState) {
        cmd_buf_bind_color_state(*self, state);
    }

    pub func bind_color_write_state(self, state: *ColorWriteState) {
        cmd_buf_bind_color_write_state(*self, state);
    }

    pub func set_viewports(self, first_id: u32, viewports: *Viewport, num_viewports: u32) {
        cmd_buf_set_viewports(*self, first_id, viewports, num_viewports);
    }

    pub func set_scissors(self, first_id: u32, scissors: *Scissor, num_scissors: u32) {
        cmd_buf_set_scissors(*self, first_id, scissors, num_scissors);
    }

    pub func clear_color(self, target_id: u32, clear_mask: u32, clear_data: addr) {
        cmd_buf_clear_color(*self, target_id, clear_mask, clear_data);
    }
}

struct Queue {
    var handle: addr;

    pub func submit_commands(self, cmds: CmdList) {
        queue_submit_commands(*self, cmds);
    }

    pub func acquire_image(self, swapchain: Swapchain) -> i32 {
        return queue_acquire_image(*self, swapchain);
    }

    pub func present_image(self, swapchain: Swapchain, image_slot: i32) {
        queue_present_image(*self, swapchain, image_slot);
    }
}

struct ImageLayout {
    var data: [u64; 16];

    # TODO: Is this safe?
    pub func initialize(maker: *ImageLayoutMaker) -> ImageLayout {
        var image_layout: ImageLayout;
        image_layout_initialize(&image_layout, maker);
        return image_layout;
    }

    pub func get_size(self) -> u64 {
        return image_layout_get_size(self);
    }

    pub func get_alignment(self) -> u32 {
        return image_layout_get_alignment(self);
    }
}

struct Image {
    var data: [u64; 16];

    # TODO: Is this safe?
    pub func initialize(layout: *ImageLayout, mem_block: MemBlock, offset: u32) -> Image {
        var image: Image;
        image_initialize(&image, layout, mem_block, offset);
        return image;
    }
}

struct Swapchain {
    var handle: addr;
}

enum Result {
    SUCCESS,
    FAIL,
    TIMEOUT,
    OUT_OF_MEMORY,
    NOT_IMPLEMENTED,
    MISALIGNED_SIZE,
    MISALIGNED_DATA,
    BAD_INPUT,
    BAD_FLAGS,
    BAD_STATE,
}

type CmdList = addr;

struct DeviceFlags {
    const DEPTH_ZERO_TO_ONE: u32 = 0 as u32 << 8;
    const DEPTH_MINUS_ONE_TO_ONE: u32 = 1 as u32 << 8;
    const ORIGIN_UPPER_LEFT: u32 = 0 as u32 << 9;
    const ORIGIN_LOWER_LEFT: u32 = 1 as u32 << 9;
    const Y_AXIS_POINTS_UP: u32 = 0 as u32 << 10;
    const Y_AXIS_POINTS_DOWN: u32 = 1 as u32 << 10;
}

struct DeviceMaker {
    var user_data: addr;
    var cb_debug: func(user_data: addr, context: *u8, result: Result, message: *u8) -> void;
    var cb_alloc: func(user_data: addr, alignment: u64, size: u64, out: *addr) -> Result;
    var cb_free: func(user_data: addr, mem: addr) -> void;
    var flags: u32;

    pub func new() -> DeviceMaker {
        return DeviceMaker {
            user_data: null,
            cb_debug: null,
            cb_alloc: null,
            cb_free: null,
            flags: DeviceFlags.DEPTH_ZERO_TO_ONE | DeviceFlags.ORIGIN_UPPER_LEFT,
        };
    }

    pub func create(self) -> Device {
        return device_create(self);
    }
}

struct MemAccess {
    const NONE: u32 = 0;
    const UNCACHED: u32 = 1;
    const CACHED: u32 = 2;
    const MASK: u32 = 3;
}

struct MemBlockFlags {
    const CPU_ACCESS_SHIFT: u32 = 0;
    const GPU_ACCESS_SHIFT: u32 = 2;

    const CPU_UNCACHED: u32 = MemAccess.UNCACHED << CPU_ACCESS_SHIFT;
    const CPU_CACHED: u32 = MemAccess.CACHED << CPU_ACCESS_SHIFT;
    const CPU_ACCESS_MASK: u32 = MemAccess.MASK << CPU_ACCESS_SHIFT;
    const GPU_UNCACHED: u32 = MemAccess.UNCACHED << GPU_ACCESS_SHIFT;
    const GPU_CACHED: u32 = MemAccess.CACHED << GPU_ACCESS_SHIFT;
    const GPU_ACCESS_MASK: u32 = MemAccess.MASK << GPU_ACCESS_SHIFT;

    const CODE: u32 = 1 as u32 << 4;
    const IMAGE: u32 = 1 as u32 << 5;
    const ZERO_FILL_INIT: u32 = 1 as u32 << 8;
}

struct MemBlockMaker {
    var device: Device;
    var size: u32;
    var flags: u32;
    var storage: addr;

    pub func new(device: Device, size: u32) -> MemBlockMaker {
        return MemBlockMaker {
            device: device,
            size: size,
            flags: MemBlockFlags.CPU_UNCACHED | MemBlockFlags.GPU_CACHED,
            storage: null,
        };
    }

    pub func create(self) -> MemBlock {
        return mem_block_create(self);
    }
}

struct CmdBufMaker {
    var device: Device;
    var user_data: addr;
    var cb_add_mem: func(user_data: addr, cmdbuf: CmdBuf, min_req_size: usize);

    pub func new(device: Device) -> CmdBufMaker {
        return CmdBufMaker {
            device: device,
            user_data: null,
            cb_add_mem: null,
        };
    }

    pub func create(self) -> CmdBuf {
        return cmd_buf_create(self);
    }
}

struct QueueFlags {
    const GRAPHICS: u32 = 1 as u32 << 0;
    const COMPUTE: u32 = 1 as u32 << 1;
    
    const MEDIUM_PRIO: u32 = 0 as u32 << 2;
    const HIGH_PRIO: u32 = 1 as u32 << 2;
    const LOW_PRIO: u32 = 2 as u32 << 2;
    const PRIO_MASK: u32 = 3 as u32 << 2;

    const ENABLE_ZCULL: u32 = 0 as u32 << 4;
    const DISABLE_ZCULL: u32 = 1 as u32 << 4;
}

struct QueueMaker {
    var device: Device;
    var flags: u32;
    var command_memory_size: u32;
    var flush_threshold: u32;
    var per_warp_scratch_memory_size: u32;
    var max_concurrent_compute_jobs: u32;

    pub func new(device: Device) -> QueueMaker {
        return QueueMaker {
            device: device,
            flags: QueueFlags.GRAPHICS | QueueFlags.COMPUTE | QueueFlags.MEDIUM_PRIO | QueueFlags.ENABLE_ZCULL,
            command_memory_size: 0x10000,
            flush_threshold: 0x2000,
            per_warp_scratch_memory_size: 0x800,
            max_concurrent_compute_jobs: 128,
        };
    }

    pub func create(self) -> Queue {
        return queue_create(self);
    }
}

enum ImageType {
    NONE = 0,
    TYPE_2D = 2,
}

struct ImageFlags {
    const HW_COMPRESSION: u32 = 1 as u32 << 2;
    const USAGE_RENDER: u32 = 1 as u32 << 8;
    const USAGE_PRESENT: u32 = 1 as u32 << 10;
}

enum ImageFormat {
    NONE = 0,
    RGBA8_UNORM = 28,
}

enum ImageSwizzle {
    ZERO = 0,
    ONE = 1,
    RED = 2,
    GREEN = 3,
    BLUE = 4,
    ALPHA = 5,
}

enum MsMode {
    MODE_1X = 0,
    MODE_2X = 1,
    MODE_4X = 2,
    MODE_8X = 3,
}

enum DsSource {
    DEPTH = 0,
    STENCIL = 1,
}

struct ImageLayoutMaker {
    var device: Device;
    var type_: ImageType;
    var flags: u32;
    var format: ImageFormat;
    var ms_mode: MsMode;
    var dimensions: [u32; 3];
    var mip_levels: u32;
    var pitch_stride_or_tile_size: u32;

    pub func new(device: Device) -> ImageLayoutMaker {
        return ImageLayoutMaker {
            device: device,
            type_: ImageType.TYPE_2D,
            flags: 0,
            format: ImageFormat.NONE,
            ms_mode: MsMode.MODE_1X,
            dimensions: [0, 0, 0],
            mip_levels: 1,
            pitch_stride_or_tile_size: 0,
        };
    }
}

struct ImageView {
    var image: *Image;
    var type_: ImageType;
    var format: ImageFormat;
    var swizzle: [ImageSwizzle; 4];
    var ds_source: DsSource;
    var layer_offset: u16;
    var layer_count: u16;
    var mip_level_offset: u8;
    var mip_level_count: u8;

    pub func new(image: *Image) -> ImageView {
        return ImageView {
            image: image,
            type_: ImageType.NONE,
            format: ImageFormat.NONE,
            swizzle: [ImageSwizzle.RED, ImageSwizzle.GREEN, ImageSwizzle.BLUE, ImageSwizzle.ALPHA],
            ds_source: DsSource.DEPTH,
            layer_offset: 0,
            layer_count: 0,
            mip_level_offset: 0,
            mip_level_count: 0,
        };
    }
}

struct Viewport {
    var x: f32;
    var y: f32;
    var width: f32;
    var height: f32;
    var near: f32;
    var far: f32;
}

struct Scissor {
    var x: u32;
    var y: u32;
    var width: u32;
    var height: u32;
}

struct RasterizerState {
    var data: u32;

    func new() -> RasterizerState {
        return RasterizerState { data: 0x00000751 };
    }
}

struct ColorState {
    var data: u32;

    func new() -> ColorState {
        return ColorState { data: 0x00080300 };
    }
}

struct ColorMask {
    const R: u32 = 1 as u32 << 0;
    const G: u32 = 1 as u32 << 1;
    const B: u32 = 1 as u32 << 2;
    const A: u32 = 1 as u32 << 3;

    const RGB: u32 = R | G | B;
    const RGBA: u32 = R | G | B | A;
}

struct ColorWriteState {
    var data: u32;

    pub func new() -> ColorWriteState {
        return ColorState { data: 0xFFFFFFFF };
    }
}

struct SwapchainMaker {
    var device: Device;
    var native_window: addr;
    var images: **Image;
    var num_images: u32;

    pub func new(device: Device, native_window: addr, images: **Image, num_images: u32) -> SwapchainMaker {
        return SwapchainMaker {
            device: device,
            native_window: native_window,
            images: images,
            num_images: num_images,
        };
    }

    pub func create(self) -> Swapchain {
        return swapchain_create(self);
    }
}

@[link_name=dkDeviceCreate] native func device_create(maker: *DeviceMaker) -> Device;
@[link_name=dkMemBlockCreate] native func mem_block_create(maker: *MemBlockMaker) -> MemBlock;
@[link_name=dkCmdBufCreate] native func cmd_buf_create(maker: *CmdBufMaker) -> CmdBuf;
@[link_name=dkCmdBufAddMemory] native func cmd_buf_add_memory(obj: CmdBuf, mem: MemBlock, offset: u32, size: u32);
@[link_name=dkCmdBufFinishList] native func cmd_buf_finish_list(obj: CmdBuf) -> CmdList;
@[link_name=dkCmdBufBindRenderTargets] native func cmd_buf_bind_render_targets(obj: CmdBuf, color_targets: **ImageView, num_color_targets: u32, depth_target: *ImageView);
@[link_name=dkCmdBufBindRasterizerState] native func cmd_buf_bind_rasterizer_state(obj: CmdBuf, state: *RasterizerState);
@[link_name=dkCmdBufBindColorState] native func cmd_buf_bind_color_state(obj: CmdBuf, state: *ColorState);
@[link_name=dkCmdBufBindColorWriteState] native func cmd_buf_bind_color_write_state(obj: CmdBuf, state: *ColorWriteState);
@[link_name=dkCmdBufSetViewports] native func cmd_buf_set_viewports(obj: CmdBuf, first_id: u32, viewports: *Viewport, num_viewports: u32);
@[link_name=dkCmdBufSetScissors] native func cmd_buf_set_scissors(obj: CmdBuf, first_id: u32, scissors: *Scissor, num_scissors: u32);
@[link_name=dkCmdBufClearColor] native func cmd_buf_clear_color(obj: CmdBuf, target_id: u32, clear_mask: u32, clear_data: addr);
@[link_name=dkQueueCreate] native func queue_create(maker: *QueueMaker) -> Queue;
@[link_name=dkQueueSubmitCommands] native func queue_submit_commands(obj: Queue, cmds: CmdList);
@[link_name=dkQueueAcquireImage] native func queue_acquire_image(obj: Queue, swapchain: Swapchain) -> i32;
@[link_name=dkQueuePresentImage] native func queue_present_image(obj: Queue, swapchain: Swapchain, image_slot: i32);
@[link_name=dkImageLayoutInitialize] native func image_layout_initialize(obj: *ImageLayout, maker: *ImageLayoutMaker);
@[link_name=dkImageLayoutGetSize] native func image_layout_get_size(obj: *ImageLayout) -> u64;
@[link_name=dkImageLayoutGetAlignment] native func image_layout_get_alignment(obj: *ImageLayout) -> u32;
@[link_name=dkImageInitialize] native func image_initialize(obj: *Image, layout: *ImageLayout, mem_block: MemBlock, offset: u32);
@[link_name=dkSwapchainCreate] native func swapchain_create(maker: *SwapchainMaker) -> Swapchain;
